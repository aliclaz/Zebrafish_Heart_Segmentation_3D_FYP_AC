# -*- coding: utf-8 -*-
"""maths_stats.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Phpsmg-THszNynYiCYPB-8HX0UONcjhx
"""

import pandas as pd
import numpy as np
from statistics import fmean, stdev
import math

__all__ = ['get_class_volumes', 'get_class_volume_msd', 'get_CIs', 'stat_sig_diff_test']

def get_class_volumes(mask, scale):
    flat_mask = mask.flatten()
    class_pixel_count = np.bincount(flat_mask)
    class_vols = class_pixel_count * ((pow(scale, 3)) / (pow(mask.shape[0], 3)))
            
    return class_vols

def get_class_volume_msd(masks, classes, scales, hpf, GM):
    class_vols_df = pd.DataFrame(index=classes, dtype=float)
    mean_column = ['Mean {} Volume (\u03bcm\u00b2) at {}HPF'.format(GM, hpf)]
    mean_class_vols_df = pd.DataFrame(index=classes, columns=mean_column, dtype=float)
    sd_column = ['Standard Deviation of {} Volume (\u03bcm\u00b2) at {}HPF'.format(GM, hpf)]
    sd_class_vols_df = pd.DataFrame(index=classes, columns=sd_column, dtype=float)

    for i in range(len(masks)):
        fish = i + 1
        class_vols = get_class_volumes(masks[i], scales[i])
        class_vols_df['{}HPF Fish {} {} Volume (\u03bcm\u00b2)'.format(hpf, fish, GM)] = class_vols
    
    for c in classes:
        mean_class_vols_df.loc[c, mean_column] = fmean(class_vols_df.loc[c,:].values.tolist())
        sd_class_vols_df.loc[c, sd_column] = stdev(class_vols_df.loc[c,:].values.tolist())

    msd_class_vols_df = pd.concat([mean_class_vols_df, sd_class_vols_df], axis=1)

    return msd_class_vols_df

def get_CIs(sds, n_samples, classes, hpf, GM):
    CIs = []
    column = ['Confidence Interval of Mean {} Volume (\u03bcm\u00b2) at {}HPF'.format(GM, hpf)]
    CI_df = pd.DataFrame(index=classes, columns=column, dtype=float)
    for sd in sds:
        CI = (2.776*sd)/(math.sqrt(n_samples))
        CIs.append(CI)
    
    CI_df[column[0]] = CIs

    return CI_df

def stat_sig_diff_test(input, mean, CI):
        if input > mean:
            if (mean + CI) >= input:
                return False
            elif (mean + CI) < input:
                return True
        elif input < mean:
            if (mean - CI) <= input:
                return False
            elif (mean - CI) > input:
                return True
        else:
            return False